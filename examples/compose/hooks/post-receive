#!/bin/sh
# ------------------------------------------------------------------------------
# Script: post-receive 
# Description: This hook is triggered after a successful 'git push' to a BARE 
#              repository. It executes a shallow clone of the latest code onto 
#              the remote host using SSH and then triggers a deployment restart.
# ------------------------------------------------------------------------------

# --- Configuration ---
# Target branch for deployments.
TARGET_BRANCH="refs/heads/main"

# Log file path within the container.
LOG_FILE="/var/log/git-deploy.log"

# Remote Server Configuration (Host machine where deployment occurs)
SSH_HOST="host.docker.internal"

# Validate essential environment variables are set.
if [ -z "$SSH_USER" ]; then echo "Error: SSH_USER not set." >&2; exit 1; fi
if [ -z "$SSH_PASSWORD" ]; then echo "Error: SSH_PASSWORD not set." >&2; exit 1; fi
if [ -z "$REMOTE_DEPLOY_BASE" ]; then
    echo "Error: REMOTE_DEPLOY_BASE environment variable is not set. This must point to the root deployment directory on the remote host (e.g., /opt/apps)." >&2
    exit 1
fi
if [ -z "$CONTAINER_CLI" ]; then echo "Error: CONTAINER_CLI not set." >&2; exit 1; fi
if [ "$CONTAINER_CLI" != "nerdctl" ] && [ "$CONTAINER_CLI" != "docker" ]; then
    echo "Error: Invalid value for CONTAINER_CLI." >&2; exit 1; fi

# Get the name of the bare repository and remove the .git suffix
REPO_PATH=$(git rev-parse --absolute-git-dir)
REPO_DIR_NAME=$(basename "$REPO_PATH" .git)

# The final path on the remote host where the code will be cloned.
# Example: $REMOTE_DEPLOY_BASE/myproject (e.g., /deploy/myproject)
REMOTE_REPO_PATH="${REMOTE_DEPLOY_BASE}/${REPO_DIR_NAME}"

# The source path for the clone is the container's *own* bare repo path.
CLONE_SOURCE_PATH="$REPO_PATH"

# SSH command prefix using sshpass.
SSH_COMMAND_PREFIX="sshpass -p \"$SSH_PASSWORD\" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \"$SSH_USER@$SSH_HOST\""

# --- Utility Functions (unchanged) ---

log_message() {
    local message="$1"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S %Z")
    echo "[$timestamp] $message"
    if [ -n "$LOG_FILE" ]; then
        echo "[$timestamp] $message" >> "$LOG_FILE"
    fi
}

handle_error() {
    local message="$1"
    log_message "Error: $message"
    exit 1
}

remote_exec() {
    local command="$1"
    log_message "Executing remotely on $SSH_HOST: $command"
    eval "$SSH_COMMAND_PREFIX \"source .profile && $command\"" 2>&1 | tee -a "$LOG_FILE"
    local status=$?
    if [ $status -ne 0 ]; then
        handle_error "Remote command failed (exit code $status): '$command'."
    fi
}

# --- Deployment Functions ---

remote_clone_repo() {
    log_message "Cloning/Updating code on $SSH_HOST to directory: $REMOTE_REPO_PATH"

    # Command to check if the deployment directory exists and is a Git repo
    local CHECK_REPO_CMD="[ -d \"$REMOTE_REPO_PATH/.git\" ]"
    
    # Check if the repo has been cloned before
    remote_exec "$CHECK_REPO_CMD"
    local REPO_EXISTS=$?

    if [ $REPO_EXISTS -eq 0 ]; then
        # If repo exists, perform a shallow pull
        log_message "Repository exists. Performing shallow pull to update."
        local PULL_CMD="cd \"$REMOTE_REPO_PATH\" && git checkout $TARGET_BRANCH && git pull --depth 1 origin $TARGET_BRANCH"
        remote_exec "$PULL_CMD"
    else
        # If repo does not exist, perform a shallow clone
        log_message "Repository does not exist. Performing shallow clone."
        # Use $REMOTE_DEPLOY_BASE here to create the root directory if needed
        local CLONE_CMD="mkdir -p \"$REMOTE_DEPLOY_BASE\" && cd \"$REMOTE_DEPLOY_BASE\" && git clone --depth 1 \"$CLONE_SOURCE_PATH\" \"$REPO_DIR_NAME\""
        remote_exec "$CLONE_CMD"
    fi
}

remote_stop_containers() {
    log_message "Stopping and removing existing containers on $SSH_HOST using $CONTAINER_CLI..."
    remote_exec "cd \"$REMOTE_REPO_PATH\" && $CONTAINER_CLI compose down --remove-orphans"
}

remote_start_containers() {
    log_message "Starting the new containers on $SSH_HOST using $CONTAINER_CLI..."
    local compose_profiles_args=""

    if [ -n "$PROFILE" ]; then
        for profile in $PROFILE; do
            compose_profiles_args="$compose_profiles_args --profile \"$profile\""
        done
        log_message "Using Docker Compose profiles: $PROFILE"
    else
        log_message "No specific Docker Compose profiles set. Starting default services."
    fi

    local compose_up_command="cd \"$REMOTE_REPO_PATH\" && $CONTAINER_CLI compose $compose_profiles_args up -d"
    remote_exec "$compose_up_command"
}

# --- Main execution block ---
log_message "Post-receive hook execution started."

# Read all incoming refs from stdin
while read oldrev newrev ref; do
    log_message "Received push event for ref: '$ref' (old: '$oldrev', new: '$newrev')"

    if [ "$ref" = "$TARGET_BRANCH" ]; then
        log_message "Detected update to the target branch: '$TARGET_BRANCH'"

        # 1. Clone/Update the code on the remote host
        remote_clone_repo

        # 2. Restart the containers with the new code
        remote_stop_containers
        remote_start_containers

        log_message "Deployment process completed successfully for branch '$TARGET_BRANCH' on $SSH_HOST."
    else
        log_message "Push event was for a different branch ('$ref'). Skipping deployment."
    fi
done

log_message "Post-receive hook execution finished."
exit 0
