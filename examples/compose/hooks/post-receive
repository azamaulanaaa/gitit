#!/bin/sh
# ------------------------------------------------------------------------------
# Script: post-receive 
# Description: This hook is triggered after a successful 'git push' to a BARE 
#              repository. It executes a shallow clone of the latest code onto 
#              the remote host using SSH and then triggers a deployment restart.
# ------------------------------------------------------------------------------

if [ -f /etc/gitit.env ]; then
    set -a
    . /etc/gitit.env
    set +a
fi

# --- Configuration ---
# Target branch for deployments.
TARGET_BRANCH="refs/heads/main"

# Log file path within the container.
LOG_FILE="/var/log/git-deploy.log"

# Remote Server Configuration (Host machine where deployment occurs)
SSH_HOST="host.docker.internal"

# Validate essential environment variables are set.
if [ -z "$SSH_USER" ]; then echo "Error: SSH_USER not set." >&2; exit 1; fi
if [ -z "$SSH_PASSWORD" ]; then echo "Error: SSH_PASSWORD not set." >&2; exit 1; fi
if [ -z "$REMOTE_DEPLOY_BASE" ]; then
    echo "Error: REMOTE_DEPLOY_BASE environment variable is not set. This must point to the root deployment directory on the remote host (e.g., /opt/apps)." >&2
    exit 1
fi
if [ -z "$CONTAINER_CLI" ]; then echo "Error: CONTAINER_CLI not set." >&2; exit 1; fi
if [ "$CONTAINER_CLI" != "nerdctl" ] && [ "$CONTAINER_CLI" != "docker" ]; then
    echo "Error: Invalid value for CONTAINER_CLI." >&2; exit 1; fi

# Get the name of the bare repository and remove the .git suffix
REPO_PATH=$(git rev-parse --absolute-git-dir)
REPO_DIR_NAME=$(basename "$REPO_PATH" .git)

# The final path on the remote host where the code will be cloned.
# Example: $REMOTE_DEPLOY_BASE/myproject (e.g., /deploy/myproject)
REMOTE_REPO_PATH="${REMOTE_DEPLOY_BASE}/${REPO_DIR_NAME}"

LOCAL_TEMP_DIR="/tmp/${REPO_DIR_NAME}-deploy"

# The source path for the clone is the container's *own* bare repo path.
CLONE_SOURCE_PATH="$REPO_PATH"

# SSH command prefix using sshpass.
SSH_COMMAND_PREFIX="sshpass -p \"$SSH_PASSWORD\" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \"$SSH_USER@$SSH_HOST\""

# --- Utility Functions (unchanged) ---

log_message() {
    local message="$1"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S %Z")
    echo "[$timestamp] $message"
    if [ -n "$LOG_FILE" ]; then
        echo "[$timestamp] $message" >> "$LOG_FILE"
    fi
}

handle_error() {
    local message="$1"
    log_message "Error: $message"
    exit 1
}

# remote_exec: Executes a command remotely, checking for errors.
# $1: command (string) - The command to execute on the remote host.
# $2: log_output (boolean, optional) - Set to 'false' to suppress output 
#     and bypass the tee pipe, useful for status checks. Default is 'true'.
remote_exec() {
    local command="$1"
    local log_output="${2:-true}" # Default to 'true'
    local status

    log_message "Executing remotely on $SSH_HOST: $command"

    # The core SSH command using sshpass
    local full_ssh_command="${SSH_COMMAND_PREFIX} \"source .profile && $command\""
    
    if [ "$log_output" = "true" ]; then
        # Standard execution with logging (Pipe status is lost, but error handling is local)
        eval "$full_ssh_command" 2>&1 | tee -a "$LOG_FILE"
        # Since the pipe is used, we cannot reliably get the remote command's status here.
        # We rely on the remote check functions to handle status separately.
        # This function should only be used for commands we expect to succeed (like 'git pull').
        status=$?
        
        # NOTE: If we get here, the pipe to tee was successful (status=0), 
        # so we cannot reliably handle the remote command failure in this block 
        # without PIPESTATUS. However, we keep it for general execution logging.
        # We will NOT check the status here for log_output=true to avoid false positives.

    else
        # Execution for status checks (Output suppressed, status preserved)
        eval "$full_ssh_command" > /dev/null 2>&1
        status=$?
        
        # Crucially, return the status for the caller to capture.
        return $status
    fi
    
    # If log_output was 'true', we don't return a status, but if we reached 
    # the end of the function successfully, we return 0.
    return 0
}

# --- Deployment Functions ---
#
local_checkout_and_scp() {
    log_message "Starting local checkout and SCP recursive transfer to $SSH_HOST:${REMOTE_REPO_PATH}"

    # 1. Prepare Local Environment (Clone/Update)
    if [ -d "$LOCAL_TEMP_DIR" ]; then
        log_message "Temporary directory exists. Fetching and hard-resetting latest code."
        # Use git fetch and reset --hard for a fast, clean update.
        ( cd "$LOCAL_TEMP_DIR" && git fetch origin $TARGET_BRANCH && git reset --hard FETCH_HEAD ) || handle_error "Local git fetch/reset failed."
    else
        log_message "Temporary directory does not exist. Performing local clone."
        # Create a new local working copy from the bare repo
        mkdir -p "$LOCAL_TEMP_DIR"
        # Clone the bare repo's contents to the temporary working directory
        git clone --bare="$REPO_PATH" "$REPO_PATH" "$LOCAL_TEMP_DIR" || handle_error "Local git clone failed."
    fi

    # 2. Prepare Remote Environment
    log_message "Ensuring deployment directory $REMOTE_REPO_PATH exists on remote host."
    remote_exec "mkdir -p \"$REMOTE_REPO_PATH\""
    
    # Optional: Clear the remote deployment directory before copy 
    # This prevents old, deleted files from remaining on the remote host.
    log_message "Cleaning existing remote deployment directory."
    remote_exec "rm -rf \"$REMOTE_REPO_PATH\"/*"
    remote_exec "rm -rf \"$REMOTE_REPO_PATH\"/.* 2>/dev/null || true"


    # 3. SCP Recursive Transfer
    log_message "Transferring code via SCP (full copy)..."
    
    # SCP flags:
    # -r: recursive copy (required for directories)
    # The source path "$LOCAL_TEMP_DIR/*" copies the *contents* (excluding hidden files).
    # Hidden files like .gitignore, .env etc. must be copied separately if needed.
    # To copy all files including hidden ones, we need a slightly complex copy strategy:
    
    # First, copy regular files (excluding .git)
    sshpass -p "$SSH_PASSWORD" scp -r -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "$LOCAL_TEMP_DIR"/* "$SSH_USER@$SSH_HOST:$REMOTE_REPO_PATH" 2>&1 | tee -a "$LOG_FILE"
    
    local status=$?
    
    # Second, copy hidden files and directories (excluding . and ..)
    # Note: scp handles the final destination folder creation if it copies a full directory.
    # Since we are copying CONTENTS, we need to handle hidden files manually or rely on `rsync`.
    # Sticking to the simplest: copy the entire temporary directory contents.
    
    # Let's revert to a simpler SCP that copies the entire directory, and the remote mkdir will be sufficient:
    log_message "Copying directory contents: $LOCAL_TEMP_DIR to $REMOTE_REPO_PATH"
    
    # Use -r to copy recursively, and the trailing slash on the source to copy contents.
    sshpass -p "$SSH_PASSWORD" scp -r -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "$LOCAL_TEMP_DIR"/ "$SSH_USER@$SSH_HOST:$REMOTE_REPO_PATH" 2>&1 | tee -a "$LOG_FILE"
    
    status=$?
    
    if [ $status -ne 0 ]; then
        handle_error "SCP transfer failed (exit code $status)."
    fi

    log_message "SCP transfer successful."
}

remote_stop_containers() {
    log_message "Stopping and removing existing containers on $SSH_HOST using $CONTAINER_CLI..."
    remote_exec "cd \"$REMOTE_REPO_PATH\" && $CONTAINER_CLI compose down --remove-orphans"
}

remote_start_containers() {
    log_message "Starting the new containers on $SSH_HOST using $CONTAINER_CLI..."
    local compose_profiles_args=""

    if [ -n "$PROFILE" ]; then
        for profile in $PROFILE; do
            compose_profiles_args="$compose_profiles_args --profile \"$profile\""
        done
        log_message "Using Docker Compose profiles: $PROFILE"
    else
        log_message "No specific Docker Compose profiles set. Starting default services."
    fi

    local compose_up_command="cd \"$REMOTE_REPO_PATH\" && $CONTAINER_CLI compose $compose_profiles_args up -d"
    remote_exec "$compose_up_command"
}

# --- Main execution block ---
log_message "Post-receive hook execution started."

# Read all incoming refs from stdin
while read oldrev newrev ref; do
    log_message "Received push event for ref: '$ref' (old: '$oldrev', new: '$newrev')"

    if [ "$ref" = "$TARGET_BRANCH" ]; then
        log_message "Detected update to the target branch: '$TARGET_BRANCH'"

        # 1. Clone/Update the code on the remote host
        remote_clone_repo

        # 2. Restart the containers with the new code
        remote_stop_containers
        remote_start_containers

        log_message "Deployment process completed successfully for branch '$TARGET_BRANCH' on $SSH_HOST."
    else
        log_message "Push event was for a different branch ('$ref'). Skipping deployment."
    fi
done

log_message "Post-receive hook execution finished."
exit 0
